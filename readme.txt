
    1个消息队列，1个动作队列。
        检测到外部动作就向消息队列中就相应的消息，main主循环中取消息并进行相应处理
        步进电机处理：周期性递增或递减的执行步进电机的4(或8)步。

2016/7/2 15:00:59  PWM控制灯光可行
2016/7/4 8:59:14 修改定时为0.1ms中断
		#define MAIN_Fosc		11059200UL	//定义主时钟
		#define	Timer0_Rate		10000UL		//中断频率
		#define		PWM_DUTY_MAX	100
		注意以上三者对灯光效果的影响：
		1.人的眼睛看不到闪烁，要求其闪烁频率大于10. 取100(10ms)
		2.将10ms分成100等分，则要求时钟每0.1秒一次中断. 也就是PWM周期与时钟中断相关
		用查表方式控制灯的亮度，从实验结果看较为可取
2016/7/5 17:46:57
		uart4使用参考: http://bbs.elecfans.com/jishu_546658_1_1.html
		(与RK3188相连的mcu为主MCU。另一MCU为副MCU)
		从应用场景看。可作以下处理：
								a. 主MCU(uart2)收到任何RK3188发来的数据，立即转发(uart4)给副MCU，是可行的
								b. 主MCU收到任何(uart4)副MCU发来的数据，立即转发给(uart2)RK3188，是可行的。也可直接丢弃
2016/7/6 17:14:34 
		ADC采样硬件接口完成。 修改常数定义全部以C字母开始
2016/7/7 14:53:20
		MOT在定时器中的执行(正转或反转)已完成。
2016/7/8 15:09:06 
        MOT响应串口数据. 将协议相关常数定义提到const.h文件中
2016/7/12 20:02:49
        添加动作队列完成消息的处理
2016/7/13 11:17:45
        去除主循环中的部份重新开始. 定时10KHz
        关闭中断对定时影响很大. 
        while(1)
	    {
    		EA = 0;
    		for(i = 0; i < 100; i++);
    		EA = 1;
    	}
		上面的循环部分影响中断导致定时由10K变成1.4K. 即丢失大量中断
		将定时器定义中的xdata改为idata(或data)后P2口的未知输出波形消失
		考虑换掉每个电机一个队列的方式，只用一个队列控制电机，并且电机的状态不做记录或计时(如果这样，电机状态没必要用动作队列了)
		电机可以转动. 调整到一个正常的转速(10ms/step --> 1ms/step)
2016/7/14 8:51:25
        将电机控制移出动作队列。以设置状态的方式存在
        通过烧录用的uart1与PC对接得知，PC每秒可收到一串数据(0x5a 0x03 0x09 0x00 0x00). 如此证实stc51的uart1的设置符合预期，并且发送数据正常. 通过P1显示计数的方式证实，收到数据的个数正常。
        通过解析收到的uart1命令，控制电机正转反转停止。正常
        
        换用stc15w4k61s4以后，调整定时器设定. 已经在stc15W4K61S4上达到串口控制电机的功能。6个电机全部通过串口控制验证
2016/7/16 11:07:40
        接收到数据，测得uart4输出脚有信号。通过串口工具得到uart4发送数据正常. 确认uart2发出数据正常. 确认uart2可以正常接收数据，并且正常识别及执行动作
2016/7/18 17:40:30
        加入功能栈接口
2016/7/19 16:17:03 
        完善其它I/O检测功能. 可控制速度(代码似乎还可以优化)
2016/7/20 11:07:22
        电机速度控制生效. 微调电机速度控制. 电机最高速度提高1倍. 添加电机驱动高阻态，释放电机
2016/7/21 15:46:36
        重新设定i/o端口检测方法，返回当前i/o状态。
2016/7/22 10:31:08
        A/D转换生效并取得值随电压变化(实验了现，A/D检测口悬空时得到的值随机变化). 通过定时擦除/写入/读取eeprom中的数据并发给串口，验证eeprom操作正常
2016/7/23 11:10:20
        步数控制生效. 启动/停止/反向相关加速、减速命令生效(看不到明显区别)。增加停止、反向接口. 步进行程上限类型u16改为u8
2016/7/29 10:04:52
        串口超时检测以1ms为单位(以前以10ms为单位). 调整电机控制结构体.将电机控制代码移到moto.c.h文件夹. stepMotoStat结构体中的成员名修改。stop动作。limit待完善
2016/7/30 11:20:12
        电机控制中的速度角度控制在协议及代码查表中生效. 命令长度限制速度角度的有效性. 行程控制精确到原来的1/8
2016/8/1 11:27:01
        调整电机控制数据结构(stepLimit为u16类型，使可转动上限达10圈以上). 重新将步进计数时间单元设为1ms(1ms ->1/2ms->1ms). 确认刹车/释放功能有效. 调整步进计数，及停止方式，再次补充及确认(测试结论, 控制更精准)
2016/8/4 14:45:55
        加入UART3(舵机用)功能. uart相关代码重新整理到uart.c.h文件中. charQueue_t定义在xdata区(以前在STC89C52似乎不能这么用)
2016/8/17 15:09:05
        NSLEEP的逻辑取反. 去掉被查表取代而注释掉的switch/case语句，运行正常
2016/8/18 14:50:13
        电源控制i/o口(P7.2)上电时不能正常拉高，通过定时翻转可以拉高(猜测端口驱动能力不足)。将电源控制i/o口(P7.2)由准双向弱上拉改为强推挽输出, 可得到预期结果. 修改避障检测实现, 只在左右脚轮子转动时才开启
2016/8/19 10:30:43
        查明故障: 0x33/0x36命令停止后再次0x31/0x32/0x34/0x35启动不能正常转动，原因系stop状态保持，启动时清零即可. 全部电机的转动启动前清除stop标志
2016/8/26 16:37:10
        将power按键检测单独拿出，单独处理
2016/9/8 14:08:04
        解决power_key电压检测故障(下拉电阻过大，默认的弱上拉导致power_key电平一直处于高电平状态，改为开漏状态后，正常)。另外补上主循环中漏掉的检测代码pwrKey_Detect()。
2016/9/9 15:40:54
        pwr_crl(P3.7)跟随POWER_KEY(P7.1)
2016/9/13 9:54:59
        加入拍脑袋动作检测